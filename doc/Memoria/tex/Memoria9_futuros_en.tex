\documentclass[class=article, crop=false]{standalone}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{minted}
\usepackage{xcolor}

\definecolor{bg}{rgb}{0.95,0.95,0.95}

\begin{document}

\section{Future work}
Although the work developed here satisfies the proposed objectives, it is far from exhausting
all the possibilities of the topic addressed. In fact, there is plenty of room for new
developments. Some possibilities will be discussed in its own section, providing clues on how
they can be carried out and incorporated into existing work. 

\begin{itemize}
  \item[-] As for syntax, a lot of syntax sugar can be added for lists, list comprehension,
  multiple equational definitions to replace the expressions \verb`case`, etc.

  \item[-] It might be interesting to provide the language with a system of modules such as
  Haskell, to add predefined functions and increase the characteristics of the lists.

  \item[-] In order to improve performance, the two proposals made can be put into practice,
  which, as shown in an example, can improve execution time by 50\%. The first proposal is
  partially developed in the branch \verb`optv1` of the repository.

  \item[-] It is also possible to automatically derive classes with one of the proposed tools
  or by updating the Fischer implementation. This would then have to be incorporated into the
  translation process. Once this is done, type classes could be incorporated to Sharade,
  being able to unify the operators of addition, subtraction... of the types \verb`Integer`
  and \verb`Double`.

  \item[-] It can be made more evident the incorporation of new ways of collecting the
  results. It is currently hidden and requires a basic knowledge of how the Fischer library
  works to implement them.

  \item[-] More functionality needs to be added to the compiler. Currently it does not allow
  naming the output file, it does not have options to create it as a module with its own name
  and it might be interesting to incorporate auxiliary functions into the translation so as
  not to have to deal directly with the translated code.
\end{itemize}

\subsection{Performance}

The performance of Sharade can be improved. The `permutation sort' Fischer's example takes
16 seconds to sort a list of 20 elements, very closely to Curry's MCC
compiler\cite{lux2003munster}. Sharade takes 43 seconds to sort the same list.

This is due to the intensive use of monadic programming. In the Fischer's implementation, the
functions are deterministic, in Sharade all must be nondeterministic. This produces an
important overhead of monadic programming that leads to a loss of performance of about 50\%.
Fischer does in his library a lot of monadic programming, but he is able to do a lot of
inline optimizations to reduce this use. This kind of task could be done in my
implementation, but as previously explained, the objetive of Sharade is not to persue
performance.

Applying by hand the first optimization proposed in the section of `Translation to Haskell',
this example observes a performance gain of about 50\%. It takes 18 seconds to sort a list of
20 elements. The second optimization proposed is not applicable in this example because is
indtrinsically nondeterministic.

\begin{minted}[bgcolor=bg]{haskell}
import Sharade.Prelude

insert :: Sharing s => s a -> s (List s a) -> s (List s a)
insert e ls = mPlus (cons e ls) (ls >>= (\pec -> case pec of
  Cons x xs -> cons x (insert e xs)
  _ -> mzero))

perm :: Sharing s => s (List s a) -> s (List s a)
perm ls = ls >>= (\pec -> case pec of
  Nil -> nil
  Cons x xs -> insert x (perm xs))

isSorted :: Sharing s => s (List s Integer) -> s Bool
isSorted ls = ls >>= (\pec -> case pec of
  Nil -> true
  Cons x xs -> xs >>= (\pec -> case pec of
    Nil -> true
    Cons y ys -> mAnd (mLeq x y) (isSorted cons y ys)))

sort :: Sharing s => s (List s Integer) -> s (List s Integer)
sort ls = share (perm ls) >>= (\sls -> (isSorted sls) >>= (\pec ->
  case pec of
    True -> sls
    _ -> mzero))
\end{minted}

Previously explained, each funcional application must be done with the infix operator
\verb`<#>`, because the function and the value are inside a monad. If we delete this overhead
and returning to the normal aspect of functions in Haskell, we obtain code similar to
Fischer's implementation. As I said before, it takes to sort a list of 20 elements nearly
18 seconds, very close to Fischer's implementation. This result is very satisfying since it
is a relatively easy optimization to carry out in the future. In fact, there is a partial
implementation in \verb`optv1` branch on the GitHub repository. It's partial because it lacks
the functionality to share functions, since it requires a deep modification of the
translation function. The remaining features such as high order, lazyness, sharing of
primitive types and indeterminism are working as expected.

\subsection{Observing results}

Sharade provides two forms of observing results, explained before. Sharade gives the user
the posibility of implementing its own ways os observing the results. These implementations
can be very complex like a `Branch and bound' algorithm or simpler like a `breadth first
search' or a `Iterative deepening depth-first search' or even a multithread search.

Fischer has a very interesting research\cite{fischer2009reinventing} on how to modify the
backtacking system in monadic programming in Haskell. Specifically, he shows how to implement
a `breadth first search' or a `Iterative deepening depth-first search' in Haskell. He also
reinvents the `depth-first search' of Haskell. These ideas can be used to implement your own
monad that perform the desired search and incorporate it into Sharade.

The way of collecting the results seems to be quite important in the world of indeterministic
programming. For example, Curry's KiCS2 compiler offers several ways to explore the search
space\cite{hanus2012search}.

\subsection{User defined types}

Sharade does not support the definition of arbitrary types. This is because those types would
be indeterministic, so they have to be subject to Fischer's Sharing rules and belong to a
series of type classes. Fischer has implemented an automatic derivation for arbitrary types
to its type classes, but it does not work with the current versions of Haskell. Currently, it
can be done with multiple tools such as
\verb`Template-Haskell`\cite {sheard2002template} or with
\verb`DrIFT`\cite{DrIFT} or with \verb`derive` \cite {derive}. The latter is the one used by
Fischer to implement automatic derivation of type classes. Addressing this issue was outside
the objectives, due to the need to limit the work in both time and features. Therefore,
Sharade does not support user types, leaving it as a future job.

\end{document}
